#!/usr/bin/env node

// Load modules

var Fs = require('fs');
var Hoek = require('hoek');
var Http = require('http');
var Optimist = require('optimist');
var Os = require('os');
var Url = require('url');


// Declare internals

var internals = {
    lastIndex: 0,
    schemaName: 'good.v1',
    host: Os.hostname(),
    lastIndexPath: __dirname + '/lastBroadcast',
    appVer: Hoek.loadPackage(__dirname + '/..').version || 'unknown',                       // Look up a level to get the package.json page
    defaults: {
        useLastIndex: true,
        interval: 10000
    }
};


internals.argv = Optimist.usage('Usage: $0 -c config.json -l file.log -u url -i broadcastInterval -p usePreviousIndex').argv;


internals.getLog = function (logPath, start, callback) {

    var stream = Fs.createReadStream(logPath, { start: start });
    var log = '';

    stream.on('readable', function () {

        log += stream.read().toString('ascii');
    });

    stream.once('end', function () {

        var events = log.split('\n');
        var lastEvent = events[events.length - 1];
        var bytesRead = log.length;

        if (lastEvent[lastEvent.length - 1] !== '}') {                                      // Handle any incomplete events in the log
            events.pop();
            bytesRead -= Buffer.byteLength(lastEvent);
        }

        var result = [];
        for (var i = 0, il = events.length; i < il; ++i) {
            var event = events[i];
            if (event && event[0] === '{' && event[event.length - 1] === '}') {
                try {
                    result.push(JSON.parse(event));
                } catch (err) {
                    console.error(err);
                }
            }
        }

        callback(bytesRead, result);
    });
};


internals.broadcast = function (log) {

    if (!log.length) {
        return;
    }

    var envelope = {
        schema: internals.schemaName,
        host: internals.host,
        appVer: internals.appVer,
        timestamp: Date.now(),
        events: log
    };

    internals.request(JSON.stringify(envelope));
};


internals.request = function (payload) {

    var req = Http.request(internals.requestOptions);
    req.on('error', function (err) {

        console.error(err);
    });

    req.write(payload);
    req.end();
};


internals.getConfig = function () {

    if (internals.argv.c) {
        var configFile = Fs.readFileSync(internals.argv.c);
        return JSON.parse(configFile.toString());
    }

    return {
        url: internals.argv.u,
        path: internals.argv.l[0] !== '/' ? process.cwd() + '/' + internals.argv.l : internals.argv.l,
        interval: internals.argv.i ? parseInt(internals.argv.i) : 10000,
        useLastIndex: internals.argv.p !== undefined ? !!internals.argv.p : true
    };
};


internals.logLastIndex = function (lastIndexStream, start) {

    lastIndexStream.write('\n' + start.toString(), function (err) {

        if (err) {
            console.error(err);
            return;
        }
    });
};


internals.start = function () {

    var start = 0;
    var config = internals.getConfig();
    config = Hoek.applyToDefaults(internals.defaults, config);

    if (config.useLastIndex && Fs.existsSync(internals.lastIndexPath)) {
        var lastContents = Fs.readFileSync(internals.lastIndexPath).toString().split('\n');
        start = parseInt(lastContents[lastContents.length - 1]);
        start = isNaN(start) ? 0 : start;
        Fs.truncateSync(internals.lastIndexPath);
    }

    var lastIndexStream = config.useLastIndex ? Fs.createWriteStream(internals.lastIndexPath) : null;
    internals.requestOptions = Url.parse(config.url);
    internals.requestOptions.method = 'POST';
    internals.requestOptions.headers = { 'content-type': 'application/json' };
    internals.requestOptions.agent = false;

    setInterval(function () {

        Fs.stat(config.path, function (err, stat) {

            if (err) {
                console.error(err);
                return;
            }

            if (stat.size < start) {
                start = 0;
            }

            internals.getLog(config.path, start, function (bytesRead, log) {

                start += bytesRead;
                internals.broadcast(log);
                if (lastIndexStream) {
                    internals.logLastIndex(lastIndexStream, start);
                }
            });
        });
    }, config.interval);
};

internals.start();